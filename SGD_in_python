import numpy as np
import pandas as pd
dataset = np.array([[2.771244718,1.784783929,0],
	[1.728571309,1.169761413,0],
	[3.678319846,2.81281357,0],
	[3.961043357,2.61995032,0],
	[2.999208922,2.209014212,0],
	[7.497545867,3.162953546,1],
	[9.00220326,3.339047188,1],
	[7.444542326,0.476683375,1],
	[10.12493903,3.234550982,1],
	[6.642287351,3.319983761,1]])

h = np.matrix([1,-1,1])
w_i = np.matrix([0.5,0.5])
b_i = np.matrix([-1,-1])
x = dataset[1]

def sgn(w_i,x,b_i):
	# w_i is the weight vector
	# x is the randomly sampled input
	y = np.matmul(w_i,np.transpose(np.matrix(x)))-np.transpose(b_i)
	sign = np.sign(y)
	return(sign)



tau = 10
batch = 3

# for t in range(0,tau):
sample = np.random.randint(1,len(dataset),1)
samp_x = dataset[sample][0][0:dataset.shape[1]-1]
samp_y = dataset[sample][0][dataset.shape[1]-1]

h = sgn(w_i,samp_x,b_i)

base_class = list(set(dataset[:,dataset.shape[1]-1]))
def f(base_class,h):
# tree navigation function f :# Hm → Im+1 that maps an m-bit sequence of split decisions (Hm ≡ {−1, +1}
# m) to an indicator vector that specifies a 1-of-(m + 1) encoding. 
# Such an indicator vector is only non-zero at the index of the selected leaf.
	final_direc = list(h).pop()
	if final_direc==-1:
		return(base_class[0])
	else:
		return(base_class[1])

